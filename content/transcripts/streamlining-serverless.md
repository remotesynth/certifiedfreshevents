---
_build:
  list: false
  render: never
---
**Sumit Verma**  8:54
All right, hello, everyone. My name is Sumit Verma. I'm the co founder and CTO at 1024 and really excited to share the new framework that we just released alpha version A month ago, framework 24 it's an Application Development Framework to build serverless applications. And if the genesis for the framework was I don't know what technologies most of you are working in, but if you're working in Java, you're probably using Spring, you work in Ruby, you probably use Rails. You're working in PHP. If you are, you're using Laravel or some framework. Now these days, everybody talks about building application, serverless application microservices. But if you look for Okay, I want to build a serverless application. How do I go about that? Well, there is no framework out there that gives you a full stack application framework. There are some high level frameworks like framework so. The serverless framework itself, and SST Dev, and there are some few others, but none which is a full stack Application Development Framework. So that's where we started. That's the reason, because when we were looking to build some applications, we were like, Okay, how are people doing it? And we see still people, if you're writing lambda functions, you're still trying to figure out, how do I zip this file and upload it and then connect it to API gateway, and then struggle with IAM permissions. I know Brian loves those writing those policy files. Maybe he can help out. But most of us, we hate it, right? So that was the idea is, how we can simplify that application development and build something which is lot closer to MVC framework, which most developers are familiar with, and help them just write the business logic and not worry about the infrastructure too much. So that's, that's framework 24 I'll quickly run through this deck, maybe in next five minutes, and then we will jump straight into demo. So why framework 24 reduce time to launch? There's you don't have to do any infrastructure coding, so that takes a lot of time away from your plate. Also, there's a lot of code, boilerplate code that you don't need to write, which framework automatically writes for you. So you will see as we go through the demo, it saves significant amount of time, and also it has a UI associated with it, which, again, a lot of time saving cost efficiency. As most of you probably know, that serverless environment you only pay for what you use. So as as if you're a startup who is launching a site and going and you have maybe 100 user Well, you don't want to have a provision infrastructure with what it costs you a lot of money in managing multiple environment, you only pay for what you use, built by a proven team. We've been doing this for over 20 years, and we are going to put this out as an MIT. It is already out as an MIT license, open source, so feel free to use it. Let's get into the backbone of framework 24 which is the serverless architecture. The reason we talked about in previous slide a little bit same stuff, the scalability is not an issue. When you're using serverless. Whether you have 100 user or you had 100 million user, you can scale seamlessly. And that's really important, because you don't want to write an application for MVP, a proof of concept, and when you get some traction going on, you don't want to go back and rewrite because you're having performance issues and such. So that scalability is important, cost efficiency, as already talked about, reduced operational overhead. Now this bullet point is important. If you look at the pros and cons of serverless and microservices architecture, what you will see is operational overhead is actually a con, because it is very complex to manage those different components of microservices and serverless architectures. But that's what we have done here, is made that a pro, because framework will take care of all that stuff, and the developer productivity is product of that, because you are just focused on writing business logic and deliver value to your user and not have to worry about writing too much infrastructure or boilerplate code. How do we get scalability and performance by using serverless features or AWS we are primarily focused on AWS cloud right now, down the road, maybe we'll add support for other clouds. So we are leveraging lambda, DynamoDB, API, Gateway, event driven architecture, using SQS, SNS, all those services. And as we go through the demo, you will see that as well. And we'll put this out presentation also out for you, so you don't have to worry about it and see this developer productivity. A few things, we decided to build a framework using TypeScript. I think that's the most common used language these days among developer community. Some of the benefits of also TypeScript is reduced error because we are using all the features of TypeScript, and it's it allows in ID itself. You can see errors up front, if you're if you have a typo or using wrong attribute, property, wrong class, missing import, all that stuff. So TypeScript is great at, you know, helping you avoid all those things, then we have built a CRUD convention based CRUD system in in the framework, so you just write your data model and your persistent logic works automatically, so you don't have to write any code to do your CRUD operations. And we will look at that in the demo. Same thing, auto, General. API. You don't have to write any code to generate API for those CRUD operations. Your API gets provisioned automatically. So API gateway and lambda connection happens automatically. You don't have to worry about it, as long as you follow the convention of the framework, all those things are done for you. And then the data validation framework, we have a really strong validation framework in place, which you can use for input validation, your data model validation, HTTP request validation, all those things for security. User authentication is built in we are using Cognito to provide authentication and authorization. Now, using framework, you can build any type of authentication system, but out of the box, we have authentication module, which is built using Cognito. It does allow you fine grain access control so you can do RBAC setup, and the best part is you don't have to write IAM policies around that you don't have to struggle with the identity provider in cognate or you don't have to worry about creating roles, all that stuff. Framework will manage that, and I'll show you how you will do that. You just use convention based method decorator to define how you want to restrict permission for your different endpoints. Data encryption by default, done by AWS. So we don't have to talk about that. Partitioning, non production production data is really important. The way framework is set up is you can deploy in any AWS account. In fact, the way we run is every developer that we have has their own AWS account provision, and then they deploy in their own account. Now the good thing is, because it's serverless, it hardly costs anything to run an application if it's not used behind the scene. We're using AWS CDK for all the deployment. So your code basically AWS CDK converts into a CloudFormation template and deploys it as a CloudFormation stack. But again, we don't have to worry about all that stuff. All that stuff is done in the background. CI/CD is also part of the framework. You can create CI/CD pipeline so when you deploy to when you merge to your AWS branch, it can deploy the back end application, and also the front end is deployed on amplify, and that gets set up automatically as well through GitHub. I'm going to skip through some of the things it talks about. Roadmap. Down the road, we will have other modules that we will keep adding to enhance the framework, like adding Full Text Search workflow engine integration with AI and such. But as of right now, we will just focus on basic application. This is a high level diagram of what's possible. So here you will have a headless app. You can go through Cognito, which goes through that API gateway, invokes lambda function, and then you can connect to different services, whether it be directly to your database, bedrock, AI, third party API, SES, and the other application flow typically is you want to drop some file into s3 run some asynchronous process where it imports that file into your database or performs any logic. Framework will be able to do both of these out of the box, and we will look at that in the demo in terms of code structure and packages. We have three code packages.

We have FW 24 which is the package that builds all your back end, API and infrastructure. UI, 24 is a package written in React which builds your admin portal, and we will look at that, and then CLI. 24 is command line tooling which allows you to easily do application scaffolding, build your application faster through command line. It is not doing anything magic. It just helps you in building some code faster, and then you can look at that code and expand from there. The output is a back end application and admin portal, and then you can build a front end website on top of it. All right? So we'll jump into demo right away. Now, here is the agenda. In less than 30 minutes, we'll run through a demo, we will create an app, and that app will have all these things done in the next 30 minutes. So we'll have API routes provision lambda functions created for those API routes, DynamoDB created authentication, authorization, crud, API, admin, UI to perform core operations, SES, to send mail using Q and also templated mail as three buckets, three buckets with asynchronous lifecycle processing, SQS for similar stuff. So all these things we'll be able to do in less than 30 minutes. So. All right, so let's jump into the demo. I think you guys can still see my screen. So what I will do is I will be creating an application from scratch here. As you can see, here, I am in visual code, and I'll just be running CLI commands to create application, and then we'll look at how that looks. So first thing I'm going to do is I'll log into my AWS account, and as we're going through that this, if you have any question, feel free to post it in chat. I won't be able to see it, but towards the end, we can do Q and A. Brian will be keeping track of all the questions, and we can answer anything that you ask. So first, let's go ahead and log in. So I have many accounts. I'm going to pick my sandbox account, and I'm going to give my profile a name. I'll call it submit, and let's start building an application. Now what I will do is here I have these CLI commands. I'm going to just run through these CLI commands and create application and different features. So first one, we will start with, just like how you will create any react application, most, most application these days as this kind of CLI. So we'll do CLI 24 create IMDb app. So we will be creating an app similar to IMDb, where we will be able to keep track of the movies we like. And so it's first is ask me, What is my AWS profile name? I'm going to give it the name, submit. It's asked me, What is my GitHub repo? It's not required, but GitHub is required if you're going to set up amplify and deployment through that. So we will do that in the demo. So I'm going to say my GitHub org. Name is 1024, group. And then it asks me if I want to create a back end app. I'm going to say yes, and then it goes through and it is going to start creating the back end app for me. Now the CLI, like I said, it is using a template, and using that template, it is doing application scaffolding and creating that application for me. So as it goes through, we will take a look at some of the code and see what it is doing. So first thing we can see is here, it's your typical node application. We can see here it pulled in framework 24 package from NPM, and it is now asking it to deploy the application to AWS. I'm going to say, yes, go ahead and deploy it while it's doing it. Let's take a look at source. All the application code is here under source. So if you look@index.ts you will see really basic application to start with. It's it's pulling application and API construct from framework 24 my API construct definition. There's really nothing in there. Main important thing is, I'm saying stage name is v1 so v1 gets appended to my API route. Here is my application. What I'm doing here is, I'm saying, use AWS, SDK as an external module which reduces the size of lambda function significantly. And then I say, use API, run. That's about it. So very basic application. But what's really cool is, as you see now, it's deployment is done. What happened now is, I have this endpoint called Hello World, and where that endpoint comes from. While we look at that, it's asking me if I want to create a GitHub repo, I'm going to say yes, and it'll ask me if I want to create an admin package, I'll say yes. So let it go create that. Let's look at the controller here in our application. What what happened? So in there is a Hello World controller here. Now, inside hello world controller, we are using decorator syntax, whatever name I give here, this controller that becomes my API endpoint, and every method that I define here becomes a route in that API endpoint. So we saw earlier that we had hello world API endpoint. Let's go and see what's in there. So if I go hello world and type in print here, you see here, hello world is printed out, which comes straight from here. If I say. Ping, you'll say it says Pong. It's a JSON because we say response type here is JSON. Now what's really nice? It's very simple, hello world, but you just have to follow convention and add a file in your controller folder here, give it a name and framework automatically provisioned lambda function for you and API gateway for you, and connected that API gateway to lambda function, which is really nice that you don't have to worry about how to put all those things together. So if we actually go in here. And let me log into AWS. If I go to API gateway, here, you can see IMDb app. And here is my Hello World API gateway that got created, and all my endpoints are here. Same thing. If I go to lambda to IMDb, you can see here is my Hello work controller, and all the code that I had is right here part of my Hello World controller. So really simple, but you didn't have to do a whole lot to get your lambda function and API gateway all that working together. Now you can create as many controllers here as you need. The convention is one lambda function per controller. So that's what we do, and all the methods that you define here, those becomes method in in your API endpoint. Now what it's doing the framework is going through, and it's creating an admin portal for me. So here you can see it is it created a folder for admin portal. Now this one is a React application. If we look at package json, you will see that it will import UI, 24 package so it's asking if I want to create, amplify and get up. I'll say yes. And then in here, if we look at the source code, you will see really basic source code here as well, it's importing UI 24 package, and then from there, it's all convention and config based. So in UI 24 config, we are defining our odd config comes from the URL that's defined in env, and again, the framework automatically sets these things up for me, because it knows what the back end endpoint got created. So it knows that back end API URL, it created an s3 bucket for me where all my configs will live, and it put that bucket URL here for me.

So my menu config will be this, my entities, config, auth, config, dashboard, so all those things by default, it sets it up and in our app txt, that's what we are defining is this is our UI config, our admin portal UI will be driven through those config files that gets created, and that's about it. That's all we have to do in our React application to have a fully functional admin provision and build. There's not going to be any more code in that. And here it is. It set it up on amplify, opened up that amplify Porter for me, it takes about a couple of minutes for amplify to finish deployment, and then we'll be able to see our application in here. While it's doing that, let's go and add some more feature to our application. So I'm going to just run through commands here. I'm going to cd into my back end that I just created, and then I'll add few things. So first I'm going to do is I'm going to add authentication to my application, and we will look at the code on what it does as well. So first I'm going to add auth module. If we look at the code here, what that did is imported auth module from authcognito and define some setting for that module. I'm saying I need two groups, admin and a user group, and I want you know users to automatically sign assign to your user group. And then that's about it. And then I'm saying, use auth module. I'm going to add DynamoDB table also. So I will say CLI 24 add DynamoDB table. The table name will be IMDb, and then I'm going to add some entities, and we will look at the entity code when it deploys. So here's the sample command for how to add entity. I'll say CLI 24 add DynamoDB entity. The entity name is title, it's getting added in the table IMDb and the I want title, name and title summary property as part of that entity. Let's go ahead and add a few more of these entities, because we are building an application to store movies. So let's add some of those entities. Let's look at couple of these other commands. Now we can also add different types of properties to our entity. So I will say here, add in my title entity. Add a property called storyline, but I want it to be a WYSIWYG. So this will add a visigivic property for me. Same way. I want to add a date property format, release date, and then I want to add some relationships. So I want to create a related property for Title type in my title. I want to create a related type for genre in my title, and then I want to create a related type for country, but I want it to be multi select, so I can pick multiple countries. And then I want to have another relationship for casts, but I wanted one too many, so I'm defining here relationship is one too many, which will allow the UI to create multiple records. So that's the definition entity definition we have. I'm going to synth my app, which will generate my configs, and then we will just go ahead and deploy this app to AWS. And while the deployment is happening, we will take a look at the code on what code got generated so far. So I'll say, CLI 24 deploy, and then it's deploying my application to AWS. It will ask me if I want to deploy it now while it's doing that. So let's go ahead and say, Yes, go ahead and deploy it while it's doing that, let's look at the code that was generated. Because CLI, as I said, is only generating code. It's not making any API call. It's not doing anything magic. It just creates these files for me. So first, let's take a look at entity. So we said, add an entity. Here is the entity that got added. It's a typical, you know, model definition you will see. So that's the definition we we allow you to add. You can add any properties. You can come in here and modify this as you see fit. But by default, it added all the properties we asked it to add. So here's my title, name, title summary. Here's a storyline WYSIWYG release date, date. And then there are other entities here that we said we want title type with a name and description that's in here you can define validations and stuff for those entities as well, right here in your entity definition. But if we come back to title you see, if it is title type, we said we want it to be related entity, so it added the definition in here, and it's creating a relationship with Title type. And also it is adding definition here, which will drive our UI. So it's saying all the options for the drop down will come from this API endpoint, and I want type and ID as a label and value for those drop downs. So as we see UI, you will see, and we're saying, Give those drop down also the option to add new items in that list. So that's how all these the hopeful property definition is in here, you can see, but then let's look at the service, because we are following mvhd convention. So here's our service. If you look at our title service, you can see there's really no code in here because we're extending base entity service, all our persistent logic is in base entity service, and there's nothing in here, and we all the CRUD operations will be available to us without any code. Same way, if I go to controller and look at my title controller, you will see there is no routes defined in here because we are extending base entity controller, so all our routes are automatically provisioned through base entity controller, so I don't have to write any code for any of this. So now that the deployment is done, what we can do is let's jump in and let's take a look how our application looks. So here you can see, here's an admin that got deployed automatically based on based on all the definition and that we had done. We can start by creating an account. This is a brand new setup. So we can come in here and let's create an account. So

and this will create an account, it will set up an authentication authorization in user pool incognito, and do all those things for me. So if I go ahead and create this, it did that. We have it set up to require a verification so I'm going to check my email, and I should have, yeah, I have a verification email with a code, which I'll type in here.

**Sumit Verma**  35:43
now verified, and now I'll be able to log in. I'm logged in, and here you go. I have an full admin portal here for which I had no code written. We looked at the setup for that everything is coming from the configs that get generated automatically through the application. So if you jump in our Title List, let's because that's our most complex entity model. So let's see what it does for us. So here we can see we have a form which is automatically defined for us to build our IMDb titles. So let's see. Let's say Star Wars. I'll say something and and this is a WYSIWYG editor. So you have a lot of control. We are using block editor. It's a really nice editor. Gives you a lot of control to to to write whatever you want. Once upon a time, in a galaxy, far, away. And then you can set up your release date, title type. And now here is where it's really cool that we added the option so now you can have all this UI automatically generated for you. So you don't have to build these UI screens. So I can pick my movie, I can say genre, and I this is where we said I want to multi select. So let's say we will say USA, and then we will add another country, Canada. And then, because this is a multi select, it allows me to select multiple values. And then this is where we said we it's a one to many relationship. So allow me to create multiple records. So you can have set up like this, where you can say director and actor, and then you can pick those and then set up your one to Many relationships in the cast. Maybe I can say, church Lucas. And then you can have, you can have multiple rows. I can say, Here actor, let's just say, look, Skywalker. So and you can save it, and you can come back, edit it. You can create more records and delete it. So you get the idea that how powerful it is without you writing a lot of code, you can generate all the UI and application just from configuration and config. So that's one thing I wanted to show you guys. Let's look at some other stuff. So now what we will do is we will build a little bit more application. So we will add a mailer. So I'm going to go ahead and say, add mailer, and I'm going to use demo dot 1024, dev.com as the domain. So what this will do is add SES capability to our application, and we will look at all that code in a second. Let's finish building everything in here. I want to use SQS. So I will say, add queue, my queue, which will create an SQ SQ for me. We will look at that. How that works similarly, I want to add a topic which will be an SNS topic. So let's use that. I want to create a schedule task. So say, add task, my task. I want to create some more as three buckets. I'm. I want to create an s3 bucket with event handler, so here's a syntax for that. And again, while it's deploying, we will take a look at all that code, how that works, and then I'm going to add a test controller where we will be able to test all our these functions that we added. And let's go ahead and deploy our application. While it's deploying, let's take a look what happened when we ran those command. So first thing we said, I want to add a mailer. So it added a mailer construct here, and that's about it. It said, this is the domain for that mailer. And what that is going to do is it'll create an SES identity. It'll create a mailing queue for me send mail using that queue, give me the ability to send text mail and also templated mail. Then I said, I want to use queue. And now this is really cool. All you need to do is define, okay, which directory is your queue directory, and then in my queues directory, just following the same convention as our controller, you can add as many files as you need for as many queues you need. So in here, I'm saying my queue, using the same convention, you're using queue decorator. Give queue a name. This will create a queue with the name my queue. And then you add a function here, method called process and framework will automatically create a lambda function using this method here that you have defined, and that will be the consumer of this queue. So anytime a message is sent to this queue, this will get invoked, and whatever code is in here that will get executed. So again, that's really nice. You don't have to worry about how to create your queues, how to connect your lambda functions to your queue. How to manage permissions between your lambda and a queue, because queue cannot access lambda, lambda cannot access queue, all those permissions are automatically managed through framework, and it makes it easy for you to do all that stuff. Same thing we said we want to have tasks. So if you want to have a task, you same thing. You just define the task directory. In your tasks directory, you add your task file, give it a name, just like we did for Q, have a process method which will run on your schedule, and then you can define a schedule using either crown syntax or rate syntax, and then in that every five minutes. Now this function will run, and whatever code you have here will get executed. We said we want to have SNS topics Now that one is even simpler, you can have just an array of topics that you want to define, and that's all you need to do if you want to have notification. You can define your notification properties, and you can define email, and that's another good thing TypeScript. You don't even have to look for documentation. Hunt for it. You we have built it so you have full type support here. So as you start typing, you will see all the properties that are available, all the types that are available. If you use any wrong property, run sync test, you will get an error. So if I want to maybe have email that I want notification sent out to, then that's all you need to do. You define your emails, and this will automatically set up a email notification when anytime a message is sent to this topic. So that's that's the idea to how we can simplify lot of these things. One the last thing I'll show you here is we said we want s3 bucket. So you just define your s3 bucket, your bucket name, and that's about it. If you want s3 bucket with trigger event handler. So we are defining a bucket called my bucket. We are saying I want to event trigger anytime an object is created or removed, invoke this lambda function here, which is defined again in the function and lambda handler. Last couple of quick thing. One thing we can do before testing is you can also generate documentation. So you can say, CLI 24 generate API docs, I am your app name, and it'll generate this doc folder, which is a postman or Swagger doc, which you can import in postman directly and use use it there, which we will take a look at right now. Last. Thing, I'll run this app in watch mode so we can see output from all our API calls right here, and we will test all these functions that we added. So what I'm going to do is grab my API domain, which is right here, and I have postman collection that I had already imported for this setup. So I'm going to go in here and change the domain for my postman to this. And then let's test this. And this is what will get exported out of that export command, generate documentation command that we just did. And here is our if you want to look at test controller that we just added, it is right here and there. These are different methods that we have in our test controller, print, File, Upload File, delete, queue, mail, all that stuff. So let's run some of these functions. Let's first test everything is good. That looks good. So let's do a File Upload. Here. I'm saying upload to my bucket, and the content of the file is Hello, lambda bucket. So if I send this command, and if we go back here, you will see in the login here that we will we will get so here is our file upload command, and then here you can see hello lambda bucket, which happened because on file upload, we said we want this function to run, and that function, all it does is reads file content and logs it to file, logs it to console. So we can see full asynchronous processing happening here on upload, triggering an event and processing that file. Same thing if you want to do, if you want to run a queue, say hi there queue. Send message to my queue that we just created. We will see here that message will go to queue, and queue is already tied. So you'll see here that message got sent to queue, and then in queue here all we are doing is whatever was the message, we are logging that message to console. So as the queue triggers that lambda function, it will log whatever that was, the message that was sent to it. Last couple of things quickly, we can say, if we want to send a email, mail gets sent. If it's say, Send mail with template, I will execute that, and then in here we will see it will send mail here that method got executed, which will trigger Q. And then in between, actually, we also see here, hello from task, which is this task getting scheduled. Task that we ran getting executed as well. So mail is sent. If I go back to my email, let me quickly go to my email here, and you will see, here is emails that came out from my test. So I think that is everything. Hope you like what we have built here. Like we said, it's open source. Use it, contribute it. Give us feedback. If you like it, don't like it, good, bad, ugly, all feedback are welcome. Hopefully this helps the adoption of serverless a little bit more. It makes it easier for everybody to get in and start using and leveraging more and more serverless and build a scalable applications. Thanks a lot. Brian, back to you.

**Brian Rinaldi**  49:05
Thanks. Sumit, that was great. I'm going to pull your screen down. I also posted the GitHub URL in the chat for everybody. If you want to go check out framework 24 if you have any questions, you're going to have a little bit of time for Q and A here, so post it whichever platform you're watching from. Go ahead and post questions there. If you have questions for submit, and I'll get to them here. So first of all, like, great presentation. I think one of the things that I thought was cool about this was that when I initially tried to use AWS, it was, you know, there's all these different pieces, and trying to understand not only what each piece does, but how they all fit together, it was always a bit complicated, which is why, from a web application standpoint, so many developers use things like vercel or Netlify or other tools to kind of all that stuff so automatically handle. For me, behind the scenes, but there is a great, like, a good benefit for using, kind of the AWS primitives, you have better performance, you have a little tighter control. I think one of the things that I want you to talk about a little bit is that, you know, we saw you kind of auto generate everything, and it, you know, so that part, like, I think sometimes developers tend to get worried, oh, this is a black box. And then if I need to edit anything, I have to go through the, you know, work through the black box again, kind of thing, whereas, like, when you showed it to me, one of the things I thought was very cool was that you could go back and you can tweak any one of these things, add them without directly in the code, instead of having to kind of work through the CLI or some kind of built in tooling, correct?

**Sumit Verma**  50:46
Yeah, absolutely great question, and that's why I mentioned couple of time, is CLI is literally all it's doing is using template and generating code from that template. It helps, if you're starting out, it helps in that so you don't have to hunt down documentation and try to figure out how to write it. But in the end, all it is doing is generating that code in those folder which you can go and change as you see fit. CLI does not do any API calls. It's not doing anything in the background. There's no black black box. It is literally just generating the code. So it's faster for you to get started. Once you get familiar with the code and structure, you don't even have to use CLI. Once you know how to build controllers, you just write it yourself. There's no need to write CLI once you get that syntax. In fact, if you build your application a little bit, copilot will help you with that. So you have to go ucli, copilot will start generating those code for you automatically. Anyways, yeah,

**Brian Rinaldi**  51:48
maybe Burke can show us how to build a framework 24 Yeah. So, you know, in fact, under the covers, it's not like doing anything, but it's just CDK scripts there, right? This is like all of it's just generating a big CDK script that then it deploys everything for,

**Sumit Verma**  52:06
yeah, so CLI is just writing those templates, using those files, using template, and then framework we have built that does a lot more so, but framework is also creating all those CDK constructs. So those are all the different CDK construct. Now what we have done is using convention based. So we will look at okay, controller directory and based on the conventions that we have, have those construct automatically create your API gateway, manage permissions, connected to lambda functions and create those resources using CDK construct. And then CDK construct, in turn, creates CloudFormation templates which gets deployed as a CloudFormation stack. So if you go and I didn't do that actually, let me quickly do this. I can share my screen for a quick second and show if you go to your AWS console, what you will see is, if I log in in here, you will see there is and you go to CloudFormation. Essentially, there is one CloudFormation application that got created here, stack, and that stack has all the resources that we created, is all part of that. Now, the good thing with that is, if you're testing, you're playing out, you can just when you're done, just run the command CLI 24 delete my app, and all these things will be cleaned up, and you won't have to worry about anything. But yeah, that's what's happening in the background. Mm, hmm, yeah,

**Brian Rinaldi**  53:45
that's, that's really cool. So forgot what it's going to ask, but you know, sorry I had it. I had a question, but then I lost, I lost track of it. Forgive me, I'm still not 100% but, but yeah, so I guess one of the, oh yeah, one of the other things I wanted to kind of ask you is, you know, if somebody wanted to, who is maybe not that familiar with AWS, I think everything that is used there falls either under, like the as a free tier, or like, s3 has, like a free trial, which is, like, It's pretty extensive. So like, they could get in, start messing with stuff without necessarily needing to worry, like, I'm going to have, like, a ton of little AWS bills popping up all over the place from here to eternity. Yeah,

**Sumit Verma**  54:32
no. Great point. And yeah, all, like I said, all our developers, they use their own AWS account. Everything that we did in that application, you can have this application running 24/7, and from what I see is AWS Bill per account is maybe one or $2 so yeah, it's Yeah, everything falls under free tier. And it. Literally does not cost anything to run, at least the application, the kind of application we built.

**Brian Rinaldi**  55:06
Yeah, excellent. And, I mean, I love, I love that you guys built the whole admin piece too. But that's just, yeah, that's really cool. I haven't most of the stuff I've seen, you know, doesn't have that part of it at all. It's only kind of like, Oh, hey, we're going to make it easier just to kind of push an application in general. But like, you know how to actually do the admin pieces? You know, to add data entities into the system is really cool.

**Sumit Verma**  55:35
Yeah, the UI is a really big part of it, because we wanted to have a framework, because creating that admin portal at every time, even the design of that, and figuring out and adding that, just a lot of work. And if you're doing crud, it's all boiling stuff, right? I mean, why I need to write code to have a listing and detail the same stuff? So that's why, what's really cool is all that stuff we are doing is using configuration, so back end is actually generating a JSON file, which I didn't show, but it just generates a JSON config, and the whole UI is generated based on that JSON config. Nice, but it's a React application, so you can override any screen. You can write your own component and use those. So build it however you want to see, see fit. UI is not a requirement to use the back end, and it's vice versa, because UI is using the API as the back end is providing, which we had defined in environment and the back end. So it's, it's both are decoupled. You can use it independently as well.

**Brian Rinaldi**  56:45
Nice, excellent. Okay, good to know, alright. So, so I know you're currently, like, in, I mean, you listed as, like, an alpha this. I mean, I posted it to an AWS community I'm part of, and they're like, I haven't even heard of this. They were all surprised, like, you know? So I think it's, you know, it's brand new, right? Like me, you guys just released this. Am I correct?

**Sumit Verma**  57:09
We just released it last month. So, so brand new. We have a couple of clients using it. We have built a couple of application ourselves using it. So it is, we're releasing one of the application we built is going to be in production in in a week. So yes, brand new, but to some extent, tested. But yeah, we need more feedback from dev community, what they like, what they don't like, what improvements we can make,

**Brian Rinaldi**  57:41
yeah, awesome. Well, hopefully, you know this, this helps spread the word and people give a shot. I think it's really cool, and I appreciate all that for you. I mean, you know, for an alpha, this is pretty impressive. I mean, usually an alpha is like, Hey, this is conceptually, not something that's like, really, as feature complete as what you showed us. So, so congrats on that.
